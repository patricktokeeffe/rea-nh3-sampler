''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Denuder-based Relaxed Eddy Accumulation (REA) Flux Measurement System
'
' Laboratory for Atmospheric Research
' Department of Civil & Environmental Engineering
' Washington State University
'
' Contact:  Patrick O'Keeffe
'           pokeeffe@wsu.edu
'           (509) 335-7246
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'===============================  DEVICE CONFIGURATION  ======================================
Const CSAT3_LI7500 = 1003 'aliases for menu
Const CSAT3A_EC150 = 1004
ConstTable
  Const DATA_SRCS = CSAT3_LI7500
  'things which MUST be constants and therefore cannot be in "settings file"
  Const SDM_SPEED = 30   'default: 30 usec; accepts 8 usec - 3 msec
  Const CSAT_ADDR = 3    'default CSAT3 SDM address: 3
  Const LI7500_ADDR = 7  'default LI7500 SDM address: 7
  Const EC100_ADDR = 1   'default EC100/EC150/CSAT3A address: 1
  
  'self-imposed value limits on some settings options
  Const UPDNFLOW_MIN = 2 'max settings are specified under analog scaling
  Const ZEROFLOW_MIN = 0.4
  Const DECLIN_MIN = -35
  Const DECLIN_MAX = 35
EndConstTable

'----- WIRING -----
Const HMP_T_DF = 11
Const HMP_RH_DF = 12

Const MFC_UP_DF = 1
Const MFC_DN_DF = 2
Const MFC_UPDN_CAO = 1 'MFCs share port

Const MFC_ZERO_SE = 5  'note: single-ended
Const MFC_ZERO_CAO = 2

Const C_UPDN_OFF = 1 'C1: valve off for UP/DN MFCs
Const C_ZERO_OFF = 2 'C2: valve off for zero MFC
Const C_UPDN_PRG = 3 'C3: valve purge for UP/DN MFCs <-- purge not implemented XXX
Const C_ZERO_PRG = 4 'C4: valve purge for zero MFC
Const C_VLV_UP = 5   'C5: 3-way valve at UP denuder inlet
Const C_VLV_DN = 6   'C6: 3-way valve at DN denuder inlet
Const C_PMP_ON = 7   'C7: relay to pump power
Const C_MFC_ON = 8   'C8: power to MFCs 

'----- ANALOG SCALING -----
Const HMP_T_MULT = (60 + 40) / 1000    '-40* - 60* / 0-1V
Const HMP_T_OFF = -40
Const HMP_RH_MULT = (100 - 0) / 1000   '0-100% / 0-1V
Const HMP_RH_OFF = 0

Const UPDNFLOW_MAX = 10 '<-- used 4 settings validation
Const MFC_UPDN_MULT = UPDNFLOW_MAX / 5000 '0-10 sLpm / 0-5V
Const MFC_UPDN_OFF = 0

Const ZEROFLOW_MAX = 5 '<-- used 4 settings validation
Const MFC_ZERO_MULT = ZEROFLOW_MAX / 5000 '0-5 sLpm / 0-5V
Const MFC_ZERO_OFF = 0


'===============================  IMPORTANT CONSTANTS  ======================================
'----- PHYSICAL -----
Const Cpd = 1005.7 	          'specific heat capacity of dry air, J/(kg K)
Const Cw = 1820               'specific heat capacity of water, J/(kg K)
Const MW_h2o = 18.01528       'molecular weight of water, g/mol
Const MW_co2 = 44.010         'molecular weight of carbon dioxide, g/mol
Const MW_air = 28.98          'molecular weight of dry air, g/mol
Const MU_WPL = MW_air/MW_h2o  'Ratio of MW of dry air to that of water vapor
Const R = 8.3143*10^-3        'Universal gas constant, (kPa m^3)/(K mol)
Const Rd = R/MW_air		        'Gas constant for dry air, (kPa m^3)/(K g)
Const Rv = R/MW_h2o		        'Gas constant for water vapor, (kPa m^3)/(K g)
Const PI = 3.14159	          'Mathematical constant pi
Const RperD = PI/180          'radians per degree
Const DperR = 180/PI          'degrees per radian

'----- CUSTOM MENU DEFINITIONS -----


'----- PORT CONTROL MASKS -----
Const MASK_UPDN_OFF = 2^(C_UPDN_OFF-1)   '0000 0001
Const MASK_ZERO_OFF = 2^(C_ZERO_OFF-1)   '0000 0010
Const MASK_UPDN_PURGE = 2^(C_UPDN_PRG-1) '0000 0100
Const MASK_ZERO_PURGE = 2^(C_ZERO_PRG-1) '0000 1000
Const MASK_UP_VLV = 2^(C_VLV_UP-1)       '0001 0000
Const MASK_DN_VLV = 2^(C_VLV_DN-1)       '0010 0000
Const MASK_UPDN_VLV = (MASK_UP_VLV OR MASK_DN_VLV) '0011 0000
Const MASK_PUMP_ON = 2^(C_PMP_ON-1)      '0100 0000
Const MASK_MFC_PWR = 2^(C_MFC_ON-1)      '1000 0000

Const MASK_OFF = &B00000000
Const MASK_FLOW = (MASK_MFC_PWR OR MASK_PUMP_ON OR MASK_ZERO_OFF OR MASK_UPDN_OFF)
Const MASK_ALL = (MASK_FLOW OR MASK_UPDN_VLV)
'TODO verify reset mask, add standby mask
Const MASK_RESET = (MASK_MFC_PWR OR MASK_UPDN_OFF) 'standby: MFCs power ON, pump OFF, 
                   'up valve OFF, dn valve OFF, zero mfc NOT valve OFF, up/dn mfc valve OFF
Const MASK_RUNNING = (MASK_MFC_PWR OR MASK_PUMP_ON) 'neither MFC valve OFF 

'----- DEFAULT SETTINGS -----
Const DEF_DATA_SRCS = CSAT3_LI7500
Const DEF_SON_AZIMUTH = 0     'degEofN
Const DEF_SON_HEIGHT = 0      'm
Const DEF_SITE_DECLIN = 0     'degEofTN
Const DEF_SITE_RUFNESS = 0    'm
Const DEF_MAX_FETCH_N = 10000 'm
Const DEF_MAX_FETCH_E = 10000 'm
Const DEF_MAX_FETCH_S = 10000 'm
Const DEF_MAX_FETCH_W = 10000 'm
Const DEF_UPDN_FLOW = 10      'sLpm
Const DEF_ZERO_FLOW = 2       'sLpm
Const DEF_DBAND_MULT = 0.5    '0 < X <= 1
Const DEF_DBAND_MIN = 0.05    'm/s
Const DEF_DBAND_DEF = 0.1     'm/s


'===============================  PROGRAM OPERATION  ======================================

Const INTEG = 250      'analog integration time
Const FAST_INTV = 100  'length of main scan, msec = 10 Hz
Const FAST_BUFF = 50   '5 second buffer
Const SLOW_INTV = 1    'length of secondary scan, seconds = 1 Hz
Const STAT_INTV = 30   'frequency of output statistics, minutes

'----- SDM device options -----
Const CSAT3_CMD = 91  'trigger + get wind & temp data
Const CSAT3_OPT = INT(1000/FAST_INTV) 'calc Hz from interval
Const LI7500_CMD = 6  'get co2, h2o, press & diagnostic
Const EC100_CMD = 1  'get Ux/Uy/Uz, Ts, sonic diag, CO2, H2O, 
'** The LI7500 reports co2/h2o in _MOLAR_ density while EC100 reports in _MASS_ density **

'----- SDM device delays -----
Const CSAT3_DELAY = 2   'fixed @ 2 measurements
Const LI7500_DELAY = 2 'SDM/RS232: BaseDelay=186ms with DelayStep=2 -> Delay=199ms
Const EC100_DELAY = 0  'TODO
Const LAG_SCANS = 5     'large enough to accomodate all delays

'----- SETTINGS FILE -----
Dim filehandle As Long
Dim save_changes
Const SETTINGS_FILE = "CPU:rea_settings.dat"
Const NUM_SETTINGS = {14}
Const WRITEFILE = 0
Const READFILE = 1

Dim choices(NUM_SETTINGS)
Alias choices(1)  = cho_data_srcs
Alias choices(2)  = cho_son_azimuth
Alias choices(3)  = cho_son_height
Alias choices(4)  = cho_site_declin
Alias choices(5)  = cho_site_rufness
Alias choices(6)  = cho_max_fetch_N
Alias choices(7)  = cho_max_fetch_E
Alias choices(8)  = cho_max_fetch_S
Alias choices(9)  = cho_max_fetch_W
Alias choices(10) = cho_updn_flow
Alias choices(11) = cho_zero_flow
Alias choices(12) = cho_dband_mult
Alias choices(13) = cho_dband_min
Alias choices(14) = cho_dband_def

Dim settings(NUM_SETTINGS)
Alias settings(1)  = set_data_srcs
Alias settings(2)  = set_son_azimuth
Alias settings(3)  = set_son_height
Alias settings(4)  = set_site_declin
Alias settings(5)  = set_site_rufness
Alias settings(6)  = set_max_fetch_N
Alias settings(7)  = set_max_fetch_E
Alias settings(8)  = set_max_fetch_S
Alias settings(9)  = set_max_fetch_W
Alias settings(10) = set_updn_flow
Alias settings(11) = set_zero_flow
Alias settings(12) = set_dband_mult
Alias settings(13) = set_dband_min
Alias settings(14) = set_dband_def

Dim just_had_1hz_scan As Boolean 'data table exclusion flags
Dim inbetween_1hz_scan As Boolean


'===============================  VARIABLES  ==============================================

'----- SENSORS -----
Dim ec100_raw(12) 'Campbellsci EC100/EC150/CSAT3A

Public sonic(5)
Alias sonic(1) = sonic_Ux
Alias sonic(2) = sonic_Uy
Alias sonic(3) = sonic_Uz
Alias sonic(4) = sonic_Ts
Alias sonic(5) = sonic_diag
Units sonic = m/s
Units sonic_Ts = degC
Units sonic_diag = bitmap

Public irga(5)
Alias irga(1) = irga_CO2
Alias irga(2) = irga_H2O
Alias irga(3) = irga_press
Alias irga(4) = irga_diag
Alias irga(5) = irga_signal 'TODO figure out if/how to retain AGC or CO2/H2O signal strength
Units irga = mmol/m^3
Units irga_press = kPa
Units irga_diag = bitmap
Units irga_signal = ratio 'XXX

Public hmp45c(2)
Alias hmp45c(1) = hmp_T
Alias hmp45c(2) = hmp_RH
Units hmp_T = degC
Units hmp_RH = %

Public hmp_e 'derived, not measured
Units hmp_e = kPa

Public flow(3)
Alias flow(1) = flow_up
Alias flow(2) = flow_dn
Alias flow(3) = flow_zero
Units flow = sLpm

Public cr5k(2)
Alias cr5k(1) = LoggerTemp
Alias cr5k(2) = LoggerVoltage
Units LoggerTemp = degC
Units LoggerVoltage = Volts

'----- STATE VARIABLES -----
Public flow_setpnt(2) 'TODO Dim
Alias flow_setpnt(1) = setpnt_sample
Alias flow_setpnt(2) = setpnt_zero
Units flow_setpnt = mV

Public deadband 
Dim neg_deadband
Units deadband = m/s

Public ctrlport(8) As Boolean
Alias ctrlport(1) = updn_mfc_is_off 'up/dn MFC off signal
Alias ctrlport(2) = zero_mfc_is_off 'makeup air MFC off signal
'C3, C4 MFC valve purge logic not built into program
Alias ctrlport(3) = updn_purging 'up/dn MFC valve purge signal
Alias ctrlport(4) = zero_purging 'makeup air MFC valve purge signal
Alias ctrlport(5) = vlv_up_is_on 'REA valve up eddy
Alias ctrlport(6) = vlv_dn_is_on	'REA valve dn eddy
Alias ctrlport(7) = pump_is_on	'turns air pump off/on
Alias ctrlport(8) = mfc_pwr_is_on 'zero MFC valve

'----- PROCESSING ------
Public Uz_rot 'for real-time coord rotation
Units Uz_rot = m/s

Public disable_sonic As Boolean 'diagnostic flag handling
Public disable_irga As Boolean

Dim lagged(11) 'update lagged record retrieval if array dimensions change
Public aligned(11)
Alias aligned(1)  = lag_Uz 'match covary(6) order
Alias aligned(2)  = lag_Ux
Alias aligned(3)  = lag_Uy
Alias aligned(4)  = lag_Ts
Alias aligned(5)  = lag_sonic_diag
Alias aligned(6)  = lag_CO2
Alias aligned(7)  = lag_H2O
Alias aligned(8)  = lag_press
Alias aligned(9)  = lag_irga_diag
'Alias aligned(10) = lag_irga_signal
Alias aligned(10) = lag_vlv_up_on
Alias aligned(11) = lag_vlv_dn_on
Units lag_Ux = m/s
Units lag_Uy = m/s
Units lag_Uz = m/s
Units lag_Ts = degC
Units lag_sonic_diag = bitmap
Units lag_CO2 = mmol/m^3
Units lag_H2O = mmol/m^3
Units lag_press = kPa
Units lag_irga_diag = bitmap
'Units lag_irga_signal = ratio
'no units for valve booleans

Public denom 'for calculating mixing ratios - TODO Dim 

Public covary(6)
  'covary(1) <-- lag_Uz
  'covary(2) <-- lag_Ux
  'covary(3) <-- lag_Uz
  'covary(4) <-- lag_Ts
  'covary(5) <-- lag_CO2
  'covary(6) <-- lag_H2O

Public cov_out(22)
Alias cov_out(1)  = Ux_Avg
Alias cov_out(2)  = Uy_Avg
Alias cov_out(3)  = Uz_Avg
Alias cov_out(4)  = Ts_Avg
Alias cov_out(5)  = CO2_Avg
Alias cov_out(6)  = H2O_Avg
Alias cov_out(7)  = press_Avg
Alias cov_out(8)  = cov_Uz_Uz
Alias cov_out(9)  = cov_Uz_Ux
Alias cov_out(10) = cov_Uz_Uy
Alias cov_out(11) = cov_Uz_Ts
Alias cov_out(12) = cov_Uz_CO2
Alias cov_out(13) = cov_Uz_H2O
Alias cov_out(14) = WS_sclr_Avg
Alias cov_out(15) = WD_unit_Avg
Alias cov_out(16) = WD_unit_Std
'Alias cov_out(17) = duplicate
Alias cov_out(18) = WS_rslt_Avg
Alias cov_out(19) = WD_rslt_Avg
Alias cov_out(20) = WD_rslt_Std
Alias cov_out(21) = hmp_T_Avg
Alias cov_out(22) = hmp_e_Avg
Units Ux_Avg = m/s
Units Uy_Avg = m/s
Units Uz_Avg = m/s
Units Ts_Avg = degC
Units CO2_Avg = mmol/m^3
Units H2O_Avg = mmol/m^3
Units press_Avg = kPa
'ignore cov units
Units WS_sclr_Avg = m/s
Units WD_unit_Avg = degEofN
Units WD_unit_Std = deg
Units WS_rslt_Avg = m/s
Units WD_rslt_Avg = degEofN
Units WD_rslt_Std = deg
Units hmp_T_Avg = degC
Units hmp_e_Avg = kPa

Public hmp_e_sat_Avg 'derived from stats
Public hmp_RH_Avg
Units hmp_e_sat_Avg = kPa
Units hmp_RH_Avg = %

Dim sqrt_UV 'double-rotation calcs
Dim sqrt_UVW
Public rot_angles(4) 
Alias rot_angles(1) = CT
Alias rot_angles(2) = ST
Alias rot_angles(3) = CE
Alias rot_angles(4) = SE
Units rot_angles = radian

Public rotated(3) 'rotated output
Alias rotated(1) = U_Avg
Alias rotated(2) = V_Avg
Alias rotated(3) = W_Avg
Units rotated = m/s


'===============================  DATA TABLES  ======================================

'----- WORKING TABLES -----
DataTable(work_lag,TRUE,LAG_SCANS)
  Sample(4,sonic(1),IEEE4)
  Sample(1,sonic_diag,UINT2)
  Sample(3,irga(1),IEEE4)
  Sample(1,irga_diag,UINT2)
'  Sample(1,irga_signal,UINT2)
  Sample(1,vlv_up_is_on,Boolean)
  Sample(1,vlv_dn_is_on,Boolean)
EndTable

DataTable(work_cov,TRUE,1)
  DataInterval(0,STAT_INTV,Min,5)
  Average(1,lag_Uz,IEEE4,disable_sonic)
  Average(1,lag_Ux,IEEE4,disable_sonic)
  Average(1,lag_Uy,IEEE4,disable_sonic)
  Average(1,lag_Ts,IEEE4,disable_sonic)
  Average(1,lag_CO2,IEEE4,disable_irga)
  Average(1,lag_H2O,IEEE4,disable_irga)
  Average(1,lag_press,IEEE4,disable_irga)
  Covariance(6,covary(1),IEEE4,disable_sonic OR disable_irga,6)
  WindVector(1,lag_Ux,-1*lag_Uy,IEEE4,disable_sonic,0,1,1) 
    'Opt1: mean horiz WS, unit vctr mean WD, and std WD using Yamartino eqn
    FieldNames("WS_sclr_Avg, WD_unit_Avg, WD_unit_Std")
  WindVector(1,lag_Ux,-1*lag_Uy,IEEE4,disable_sonic,0,1,2)
    'Opt2: mean horiz WS, rslt mean WS, rslt mean WD, WS-weighted WD sdev using CSI eqn
    FieldNames("dup, WS_rslt_Avg, WD_rslt_Avg, WD_rslt_Std")
  
  Average(1,hmp_T,IEEE4,(inbetween_1hz_scan OR hmp_T=NAN))
  Average(1,hmp_e,IEEE4,(inbetween_1hz_scan OR hmp_e=NAN))
EndTable

'----- FINAL OUTPUTS -----
DataTable(ts_fast,True,-1)
  DataInterval(0,FAST_INTV,mSec,10)
  CardOut(1,-1)
  Sample(1,sonic_Ux,IEEE4)
  Sample(1,sonic_Uy,IEEE4)
  Sample(1,sonic_Uz,IEEE4)
  Sample(1,sonic_Ts,IEEE4)
  Sample(1,sonic_diag,UINT2)
  Sample(1,irga_CO2,IEEE4)
  Sample(1,irga_H2O,IEEE4)
'  Sample(1,irga_temp,IEEE4)
  Sample(1,irga_press,IEEE4)
  Sample(1,irga_diag,UINT2)
'  Sample(1,irga_co2_sig,FP2)
'  Sample(1,irga_h2o_sig,FP2)
  Sample(1,vlv_up_is_on,Boolean)
  Sample(1,vlv_dn_is_on,Boolean)
EndTable

DataTable(ts_slow,True,-1)
  DataInterval(0,SLOW_INTV,Sec,10)
  CardOut(1,-1)
  Sample(1,hmp_T,IEEE4)
  Sample(1,hmp_RH,IEEE4)
  Sample(1,flow_up,IEEE4)
  Sample(1,flow_dn,IEEE4)
  Sample(1,flow_zero,IEEE4)
EndTable

' stats file here

DataTable(info,1,100)
  CardOut(1,100)
  Sample(1,Status.CompileResults,String)
    FieldNames("CompileResults")
  Sample(1,Status.CardStatus,String)
    FieldNames("CardStatus")
'XXX 
'  Sample(1,Status.RunSignature,UINT2) 'program information
'    FieldNames("RunSig")
'  Sample(1,Status.ProgSignature,UINT2)
'    FieldNames("ProgSig")
EndTable

DataTable(progsettings,True,1000)
  CardOut(1,1000)
  'TODO track data source?
  Sample(1,set_son_azimuth,FP2)
    FieldNames("sonic_azimuth")
    Units sonic_azimuth = degEofN
  Sample(1,set_son_height,FP2)
    FieldNames("sonic_height")
    Units sonic_height = meter
  Sample(1,set_site_declin,FP2)
    FieldNames("site_magdeclin")
    Units site_magdeclin = degEofTN
  Sample(1,set_site_rufness,FP2)
    FieldNames("site_roughness")
    Units site_roughness = meter
  'changes to flow setpoints should be obvious from data files
  'XXX may record them to distinguish operator changes from issues?
  Sample(1,set_dband_mult,FP2)
    FieldNames("deadband_mult")
    Units deadband_mult = ratio
  Sample(1,set_dband_min,FP2)
    FieldNames("deadband_min")
    Units deadband_min = m/s
  Sample(1,set_dband_def,FP2)
    FieldNames("deadband_default")
    Units deadband_default = m/s
EndTable

'===============================  CUSTOM MENU  ======================================
Const Disable = False
Const Enable = True
Const Cancel = False
Const Discard = 1001
Const Save = 1002
Const Yes = True
Const SingleRun = 1005
Const Recurring = 1006
Dim recompile As Boolean
DisplayMenu("MainScreen",-1) 'or -2
  SubMenu("REA Settings")
'    SubMenu("Schedule Run")
'      MenuItem("Type", cho_run_freq)
'        MenuPick(SingleRun, Recurring)
'      MenuItem("Duration, hr", cho_run_duration)
'      MenuItem("Recur. interval", cho_run_intv)
'      MenuItem("Recur. units", cho_run_intv_unit)
'      MenuItem("Begin at", cho_run_duration)
'        MenuPick(NextInterval,TimeOfDay)
'      MenuItem("Preset")
'    EndSubMenu
    SubMenu("Flow rates")
      MenuItem("Sampling, sLpm", cho_updn_flow)
      MenuItem("Zero air, sLpm", cho_zero_flow)
    EndSubMenu
    SubMenu("Deadband")
      MenuItem("Mult. [0-1)", cho_dband_mult)
      MenuItem("Minimum, m/s", cho_dband_min)
      MenuItem("Default, m/s", cho_dband_def)
    EndSubMenu
    SubMenu("Site")
      MenuItem("Mag declin degEofTN", cho_site_declin)
      MenuItem("Roughness length, m", cho_site_rufness)
      MenuItem("Max fetch N, m", cho_max_fetch_N)
      MenuItem("Max fetch E, m", cho_max_fetch_E)
      MenuItem("Max fetch S, m", cho_max_fetch_S)
      MenuItem("Max fetch W, m", cho_max_fetch_W)
    EndSubMenu
    SubMenu("Sensors")
      MenuItem("Azimuth, degEofN", cho_son_azimuth)
      MenuItem("Height, m", cho_son_height)
    EndSubMenu
    SubMenu("Save changes")
      MenuItem("Save now?", save_changes)
        MenuPick(Cancel, Discard, Save)
      'TODO:
      'MenuItem("Reset to defaults?")
      'MenuPick(Cancel,Yes)
    EndSubMenu
    SubMenu("Internals")
      MenuItem("sonic/IRGA", DATA_SRCS)
        MenuPick(DATA_SRCS, CSAT3_LI7500, CSAT3A_EC150)
      MenuItem("SDM speed", SDM_SPEED)
      MenuItem("SDM addr: CSAT3", CSAT_ADDR)
        MenuPick(CSAT_ADDR,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
      MenuItem("SDM addr: LI7500", LI7500_ADDR)
        MenuPick(LI7500_ADDR,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
      MenuItem("SDM addr: EC100", EC100_ADDR)
        MenuPick(EC100_ADDR,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
      MenuItem("Min samp flow sLpm", UPDNFLOW_MIN)
      MenuItem("Min zero flow sLpm", ZEROFLOW_MIN)
      MenuItem("Min declin allowed", DECLIN_MIN)
      MenuItem("Max declin allowed", DECLIN_MAX)
      MenuRecompile("Recompile now?", recompile)
        MenuPick(Cancel,Yes)
    EndSubMenu
  EndSubMenu
EndMenu

'===============================  FUNCTIONS  ========================================

'estimate latent heat of vaporization by formula 8 from:
' A new formula for latent heat of vaporization as a function of temperature.
' By B. Henderson-Sellers, Dept. of Mathematics, University of Salford
' Quart. J. R. Met. Soc. (1984), 110, pp 1186-1190
' Lv = 1.91846*10^6{T/(T-33.91)}^2    where  Lv = lat. heat of vapor, J/kg
'                                            T  = temperature, Kelvin
Function LatentHeatVapH2O(temp)
  Return 1918.46*( (temp+273.15)/(temp+239.24) )^2 'J/g
EndFunction

'footprint calc, Hsieh et al, 2000
Dim Dh, Ph, Zu, Zm, Zo
Function FootprintEstimate(L_)
  Zm = set_son_height 'm
  Zo = set_site_rufness 'm
  Zu = Zm * (LOG(Zm/Zo) - 1 + (Zo/Zm))
  If (ABS(Zu/L_) < 0.04) Then 'neutral
    Dh = 0.97
    Ph = 1
  ElseIf L_ < 0 'unstable
    Dh = 0.28
    Ph = 0.59
  Else          'stable
    Dh = 2.44
    Ph = 1.33
  EndIf
  Return Dh/(0.357*0.4*0.4) * ABS(L_)^(1-Ph) * Zu^Ph
EndFunction

Dim itt_model
'integral turbulence test following Hammerle et al. (2007)
Function TurbulenceTest(zeta)
    If (zeta < -2 OR zeta >= 1) Then
      Return 999 'XXX better sentinel? NAN?
    Else
      itt_model = 1.25 * IIF(zeta < 0, (1 + 3*ABS(zeta))^(1/3.), (1 + 0.2*zeta))
      'XXX fix reference to Uz_std
      Return 100'*ABS((W_Std/u_star) - itt_model)/itt_model
    EndIf
EndFunction


'===============================  SUBROUTINES  ======================================
Sub set_default_choices()  'assume:
  cho_data_srcs = DEF_DATA_SRCS
  cho_son_azimuth = DEF_SON_AZIMUTH
  cho_son_height = DEF_SON_HEIGHT
  cho_site_declin = DEF_SITE_DECLIN
  cho_site_rufness = DEF_SITE_RUFNESS
  cho_max_fetch_N = DEF_MAX_FETCH_N
  cho_max_fetch_E = DEF_MAX_FETCH_E
  cho_max_fetch_S = DEF_MAX_FETCH_S
  cho_max_fetch_W = DEF_MAX_FETCH_W
  cho_updn_flow = DEF_UPDN_FLOW
  cho_zero_flow = DEF_ZERO_FLOW
  cho_dband_mult = DEF_DBAND_MULT
  cho_dband_min = DEF_DBAND_MIN
  cho_dband_def = DEF_DBAND_DEF
EndSub

Sub populate_choices()
  Move(choices(1),NUM_SETTINGS,settings(1),NUM_SETTINGS)
EndSub

Sub save_current_choices()
  'Input validation
  While (cho_son_azimuth < 0)
    cho_son_azimuth += 360
  Wend
  cho_son_azimuth = cho_son_azimuth MOD 360
  If (cho_son_height < 0) Then (cho_son_height = 0)
  If (cho_site_declin < DECLIN_MIN) Then (cho_site_declin = DECLIN_MIN)
  If (cho_site_declin > DECLIN_MAX) Then (cho_site_declin = DECLIN_MAX)
  If (cho_site_rufness < 0) Then (cho_site_rufness = 0)
  If (cho_max_fetch_N < 0) Then (cho_max_fetch_N = 0)
  If (cho_max_fetch_E < 0) Then (cho_max_fetch_E = 0)
  If (cho_max_fetch_S < 0) Then (cho_max_fetch_S = 0)
  If (cho_max_fetch_W < 0) Then (cho_max_fetch_W = 0)
  If (cho_updn_flow < UPDNFLOW_MIN) Then (cho_updn_flow = UPDNFLOW_MIN)
  If (cho_updn_flow > UPDNFLOW_MAX) Then (cho_updn_flow = UPDNFLOW_MAX)
  If (cho_zero_flow < ZEROFLOW_MIN) Then (cho_zero_flow = ZEROFLOW_MIN)
  If (cho_zero_flow > ZEROFLOW_MAX) Then (cho_zero_flow = ZEROFLOW_MAX)
  'note: order matters when validating dband settings!
  If (cho_dband_min < 0) Then (cho_dband_min = 0)
  If (cho_dband_def < cho_dband_min) Then (cho_dband_def = cho_dband_min)
  If (cho_dband_mult > 1) Then (cho_dband_mult = 1)
  If (cho_dband_mult <= 0) Then (cho_dband_mult = DEF_DBAND_MULT)

  'Populate dependent variables
  'irga_signal = IIF(cho_data_srcs=CSAT3_LI7500, NAN, irga_signal) 'XXX
    'LI7500 stores AGC ("signal") within diagnostic but EC150 does not
  setpnt_sample = cho_updn_flow/MFC_UPDN_MULT
  setpnt_zero = cho_zero_flow/MFC_ZERO_MULT

  Move(settings(1),NUM_SETTINGS,choices(1),NUM_SETTINGS)
  Calfile(settings,NUM_SETTINGS,SETTINGS_FILE,WRITEFILE)
EndSub

Sub setup()
  filehandle = FileOpen(SETTINGS_FILE,"rb",0)
  FileClose(filehandle)
  If (filehandle=0) Then  'file not found
    set_default_choices()
  Else
    Calfile(settings,NUM_SETTINGS,SETTINGS_FILE,READFILE)
    populate_choices()
  EndIf
  save_current_choices()
  
  Move(sonic(1),5,NAN,1)
  Move(irga(1),4,NAN,1)
  Move(hmp45c(1),2,NAN,1)
  Move(flow(1),3,NAN,1)
  
  rot_angles(1) = 1.0
  Move(rot_angles(2),3,0,1)
  
  deadband = set_dband_def
  neg_deadband = -1*deadband
  
  SDMSpeed(SDM_SPEED)
  CallTable(info)
EndSub

Sub reset_rea()
  WriteIO(MASK_ALL,MASK_RESET) 'XXX
  'set both valves off
EndSub


'===============================  MAIN PROGRAM  ======================================
BeginProg
  Call setup()
  Call reset_rea()
  Scan(FAST_INTV,mSec,FAST_BUFF,0)
    #If (DATA_SRCS=CSAT3A_EC150) Then
      EC100(ec100_raw(1),EC100_ADDR,1)
      Move(sonic(1),5,ec100_raw(1),5)
      irga_CO2 = ec100_raw(6)
      irga_H2O = ec100_raw(7)
      irga_diag = ec100_raw(8)
      irga_press = ec100_raw(10)
      'irga_signal = ec100_raw(
    #Else
      CS7500(irga_CO2,1,LI7500_ADDR,LI7500_CMD)
      CSAT3(sonic_Ux,1,CSAT_ADDR,CSAT3_CMD,CSAT3_OPT)
    #EndIf
    
    If (True) Then 'XXX in REA mode
      Uz_rot = sonic_Uz*CT - sonic_Ux*ST*CE - sonic_Uy*ST*SE 'online double rotation
      If (Uz_rot = NAN) Then
        vlv_up_is_on = False
        vlv_dn_is_on = False
      ElseIf (Uz_rot >= deadband) Then
        vlv_up_is_on = True
        vlv_dn_is_on = False
      ElseIf (Uz_rot <= neg_deadband) Then
        vlv_up_is_on = False
        vlv_dn_is_on = True
      Else 'deadband
        vlv_up_is_on = False
        vlv_dn_is_on = False
      EndIf
    EndIf
    PortSet(C_VLV_UP,vlv_up_is_on) 'not WriteIO so scheduled as measurement task
    PortSet(C_VLV_DN,vlv_dn_is_on) '  instead of (buffered) processing task

    CallTable(ts_fast)
    CallTable(work_lag)
    If (work_lag.Output(1,LAG_SCANS)) Then
      GetRecord(lagged(1),work_lag,LAG_SCANS)
      Move(aligned(10),2,lagged(10),2) 'inst. valve state
      
      If (set_data_srcs=CSAT3A_EC150) Then
        GetRecord(lagged(1),work_lag,LAG_SCANS-EC100_DELAY)
        Move(aligned(1),9,lagged(1),9)
      Else
        GetRecord(lagged(1),work_lag,LAG_SCANS-CSAT3_DELAY)
        Move(aligned(1),5,lagged(1),5)
        lag_sonic_diag = IIF(lag_sonic_diag=NAN, &h0F, lag_sonic_diag/&h1000)
        'Only retain 4 MSB (b12-b15) and if NAN, set all bits high
        
        GetRecord(lagged(1),work_lag,LAG_SCANS-LI7500_DELAY)
        Move(aligned(6),4,lagged(6),4)
        lag_irga_diag = IIF(lag_irga_diag=NAN, &hF0, lag_irga_diag XOR &hF0)
        'Flip diag bit states to proper boolean and if NAN, set all bits high
        lag_irga_diag /= &h10 'Only retain 4 MSB (b4-7)
        'TODO determine how to keep AGC value!
      EndIf
      disable_sonic = (lag_sonic_diag > 0)
      disable_irga = (lag_irga_diag > 0)

      'TODO 
      'estimate mixing ratios - not ideal to do at 10 Hz; should use stats values
      'denom = 
      
      Move(covary(1),4,lag_Uz,4) 'load covariance array
      Move(covary(5),2,lag_CO2,2)

      CallTable(work_cov)
      If (work_cov.Output(1,1)) Then
        GetRecord(cov_out(1),work_cov,1)
			  'Wind coordinate rotation: met->natural as described in: 
			  '  Chapter 3, Appendix A from Handbook of Micrometeorology, ed. Lee, Massman and Law
			  'Also in:
			  '  Finnigan J.J., Clement R., Malhi Y., Leuning R., Cleugh H.A. A re-evaluation of 
			  '  long-term flux measurement techniques, Part I: Averaging and Coordinate Rotation. 
			  '  Boundary-Layer Meteorology 107: 1-48, 2003. 
			  'Given original met components: Ux, Uy, Uz
			  'Then by forcing mean lateral & vertical winds towards zero, the rotated "streamwise" 
			  'vectors are given by:
			  '    U2 = Ux*CT*CE + Uy*CT*SE + Uz*ST
			  '    V2 = Uy*CE - Ux*SE
			  '    W2 = Uz*CT - Ux*ST*CE - Uy*ST*SE
			  '  where
			  '    CE = |U1|/sqrt( |U1|^2 + |V1|^2 )
			  '    SE = |V1|/sqrt( |U1|^2 + |V1|^2 )
			  '    CT = sqrt( |U1|^2 + |V1|^2 )/sqrt( |U1|^2 + |V1|^2 + |W1|^2 )
			  '    ST = |W1|/sqrt( |U1|^2 + |V1|^2 + |W1|^2 )
			  'These two rotations align base vector e1 (x-axis) to mean HZ WD and a third rotation 
			  'is needed to fix e2,e3. This is done by forcing Cov(Uy,Uw) to zero but since it often 
    	  'results in physically unrealistic orientations, this step is also often ignored.
			  '    U3 = U2
			  '    V3 = V2*CB + W2*SB
			  '    W3 = W2*CB - V2*SB
			  '  where
			  '    CB = cos( 0.5*atan(2*Cov(V2,W2) / (Cov(V2,V2) - Cov(W2,W2))) )
			  '    SB = sin( 0.5*atan*2*Cov(V2,W2) / (Cov(V2,V2) - Cov(W2,W2))) )
			  '
			  'In this program, only first two rotations are performed. Rotated values are used in 
			  'flux calcs but be aware this procecure acts as a high-pass filter removing contributions
			  'from eddies of period greater than averaging time (30min)!
        sqrt_UV = SQR(Ux_Avg^2 + Uy_Avg)
        sqrt_UVW = SQR(Ux_Avg^2 + Uy_Avg^2 + Uz_Avg^2)
        CE = Ux_Avg/sqrt_UV
        SE = Uy_Avg/sqrt_UV
        CT = sqrt_UV/sqrt_UVW
        ST = Uz_Avg/sqrt_UVW
        U_Avg = Ux_Avg*CT*CE + Uy_Avg*CT*SE + Uz_Avg*ST
        V_Avg = Uy_Avg*CE - Ux_Avg*SE
        W_Avg = Uz_Avg*CT - Ux_Avg*ST*CE - Uy_Avg*ST*SE
        
        'adjust WD to relect sonic azimuth
        WD_unit_Avg = (360 + WD_unit_Avg + set_son_azimuth + set_site_declin) MOD 360
        WD_rslt_Avg = (360 + WD_rslt_Avg + set_son_azimuth + set_site_declin) MOD 360

        'XXX estimate latent heat
        'Lv = LatentHeatVapH2O(mean_temp) <-- does this require HMP integration?
        
        'XXX calculate mean RH using avg T & avg e
        SatVP(hmp_e_sat_Avg,hmp_T_Avg)
        hmp_RH_Avg = 100*hmp_e_Avg/hmp_e_sat_Avg
        
        'calculate -->
        'density of dry & moist air: rho_d, rho_a
        'specific heat capacity of moist air: Cpm
        'friction velocity: u_star
        'uncorrected fluxes (e.g. cov)
        'WPL terms for water vapor flux
        'corrected sensible heat flux
        'WPL terms for carbon dioxide flux
        'Obukhov length
        'stability parameter
        'footprint
        'is within fetch
        'new deadband size deadband
        'integral turbulence test
        '(bonus: stationarity)
        'correction factors for std. L -> L
        'new sampling flow rate
        'new zero air flow rate
        
        'control REA sampling state
        'check timer, etc

      EndIf

    EndIf

    inbetween_1hz_scan = True
    If (just_had_1hz_scan) Then
      just_had_1hz_scan = False
      inbetween_1hz_scan = False
    EndIf
  NextScan


  SlowSequence
  Scan(SLOW_INTV,Sec,0,0)
    VoltDiff(hmp_T,1,mv1000,HMP_T_DF,True,0,INTEG,HMP_T_MULT,HMP_T_OFF)
    VoltDiff(hmp_RH,1,mv1000,HMP_RH_DF,True,0,INTEG,HMP_RH_MULT,HMP_RH_OFF)
    
    VoltDiff(flow_up,1,mv5000,MFC_UP_DF,True,0,INTEG,MFC_UPDN_MULT,MFC_UPDN_OFF)
    VoltDiff(flow_dn,1,mv5000,MFC_DN_DF,True,0,INTEG,MFC_UPDN_MULT,MFC_UPDN_OFF)
    VoltSe(flow_zero,1,mv5000,MFC_ZERO_SE,True,0,INTEG,MFC_ZERO_MULT,MFC_ZERO_OFF)

    VaporPressure(hmp_e, hmp_T, hmp_RH)

    CallTable(ts_slow)

    'XXX does deactivating "Boost" affect operation?
    ExciteCAO(MFC_UPDN_CAO,setpnt_sample,False,False)
    ExciteCAO(MFC_ZERO_CAO,setpnt_zero,False,False)

    If (save_changes = Discard) Then
      populate_choices()
      save_changes = Cancel
    ElseIf (save_changes = Save) Then
      save_current_choices()
      save_changes = Cancel
      CallTable(progsettings)
    EndIf
    
    just_had_1hz_scan = True
  NextScan
EndProg

